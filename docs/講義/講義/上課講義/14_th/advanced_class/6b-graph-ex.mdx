---
sidebar_position: 6.5
title: 以毒攻獨
description: ''
---

# 以毒攻獨

---
## 前言
大家應該知道了我筆電被沒收了 所以這篇基本上是用手機打的 排版很醜見諒我盡力了 等我筆電回來會修好看

然後我現在不但筆電被沒收手機還有限制時間 所以這份講義吃了我連假的一堆使用時間 打講義真好玩

## 題目要你做什麼

- 讀入多筆 9×9 數獨
- 第一行是整數 n 表示有幾題
- 每題 9 行 每行 9 個整數 0 代表空格 1~9 是已填數
- 你需要輸出每題完成後的 9×9 數獨 每行數字以空白分隔

---

## 規則

- 每一列出現 1~9 各一次
- 每一行出現 1~9 各一次
- 每一個 3×3 區塊出現 1~9 各一次

區塊編號計算公式  
blockIndex = (r / 3) * 3 + (c / 3)   r c 都從 0 開始使用整數除法

區塊視覺化

```
0 0 0 | 1 1 1 | 2 2 2
0 0 0 | 1 1 1 | 2 2 2
0 0 0 | 1 1 1 | 2 2 2
------+-------+------
3 3 3 | 4 4 4 | 5 5 5
3 3 3 | 4 4 4 | 5 5 5
3 3 3 | 4 4 4 | 5 5 5
------+-------+------
6 6 6 | 7 7 7 | 8 8 8
6 6 6 | 7 7 7 | 8 8 8
6 6 6 | 7 7 7 | 8 8 8
```

---

## 核心方法

用遞迴深度優先搜尋 從左到右 從上到下 掃格子  
遇到已填跳過  
遇到 0 就嘗試放 1~9  
合法就往下一格  
不通就恢復再換下一個數  
全部填完就成功

---

## 需要的變數(名稱參考就好）

| 名稱 | 意義 | 說明 |
|------|------|------|
| ar[9][9] | 數獨盤面 | 0 代表空格 |
| row[9][10] | 某列是否已用某數 | row[r][num] 為 true 表示使用過 |
| col[9][10] | 某行是否已用某數 | 同上 |
| blo[9][10] | 某區塊是否已用某數 | 索引用 blockIndex |
| solve(r, c) | 遞迴函式 | 嘗試處理 (r c) 這格 |
| blockIndex | 3×3 區塊索引 | (r / 3) * 3 + (c / 3) |

第二維用到 10 是為了能直接用數字 1~9 當索引 省去減 1

---

## 每題開始時要做的事

- 把 row col blo 全部設為 false
- 讀入 9×9 整數到 ar
- 逐格掃
  - 若 ar[r][c] != 0
    - num = ar[r][c]
    - blockIndex = (r / 3) * 3 + (c / 3)
    - row[r][num] = col[c][num] = blo[blockIndex][num] = true


---

## solve(r, c) 的思路

處理 (r c) 這格

- 若 r == 9  
  代表前面 0~8 列全部都完成 回傳 true
- 若 c == 9  
  進到下一列第一格 solve(r + 1 0)
- 若 ar[r][c] != 0  
  這格原本有數字 直接 solve(r c + 1)
- 否則這格是 0
  - blockIndex = (r / 3) * 3 + (c / 3)
  - 對 num 從 1 到 9
    - 檢查 row[r][num] col[c][num] blo[blockIndex][num] 是否都是 false
    - 都是 false 才能放
      - ar[r][c] = num
      - row[r][num] = col[c][num] = blo[blockIndex][num] = true
      - 若 solve(r c + 1) 回傳 true 就一路傳 true
      - 否則回溯
        - ar[r][c] = 0
        - row[r][num] col[c][num] blo[blockIndex][num] 改回 false
  - 9 個數都試完沒成功 回傳 false

---

## 回溯是什麼

試著放一個數字 往後遞迴  
後面發現無解 就把這次放的數字清掉 並把三個布林標記復原  
再換下一個數  
這樣的撤退與再嘗試就是回溯  
缺漏任何復原動作 之後檢查會誤判已使用

---

## 主程式整體流程

- 讀 n
- 迴圈每題
  - 初始化三個表為 false
  - 讀盤並標記已存在的數字
  - 呼叫 solve(0 0)
  - 依規定輸出 ar

---

## 常見錯誤與排查

| 現象 | 可能原因 | 排查方式 |
|------|----------|----------|
| 永遠解不出 | blockIndex 算錯 或 初始化遺漏 | 印出 blockIndex 與 r c 比對 |
| 無限遞迴卡住 | 忘了 c == 9 換列 | 在 solve 裡 debug 印 r c |
| 解答部分錯誤 | 回溯時沒完全清標記 | 針對某一格檢查放入與清除配對 |
| 第二題開始亂掉 | 沒重設 row col blo | 每題開始 memset |
| 執行過慢 | 判斷是否合法時仍掃行列 | 確認只用布林直接判斷 |


---

## 總之大概會長這樣

維護三張表 row col blo  
逐格遞迴  
遇 0 就試 1~9  
能放就往前 失敗就回溯  
r 走到 9 代表完成

---

## debug建議

- blockIndex 是否正確
- 回溯是否四件事都還原 ar row col blo
- 是否有處理 c == 9 換列
- 是否正確在 r == 9 回傳 true
- 每題是否重新初始化三張表

---

## 總結

用行 列 區塊三個布林快速判定 整個流程就是試 放 遞迴 不行就還原 直到填滿為止

雖然段考快到了 但讀書之餘也可以嘗試寫寫看這題吧:D