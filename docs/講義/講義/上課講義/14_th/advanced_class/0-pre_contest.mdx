---
sidebar_position: 0
title : "二篩題解"
description: ''
hide_table_of_contents: true
---

# 二篩題解
## p0 競賽用hello world
不會寫可以跟助教講
他會協助你走回初階班
## p1 千束開車(1)
### 考點
前綴和 
### 題解
如果每次詢問你都重新計算起點與終點的高度差距會TLE  
前綴和陣列構建:  
```cpp
for(int i=1;i <= n;i++){
    cin >> a[i];
    s = 0;
    e = 0;
    if(a[i] > a[i-1]){
        s = a[i] - a[i-1];
    }
    else{
    	e = a[i-1] - a[i];
    }
    pre[i] = pre[i - 1] + (s);
    pre1[i] = pre1[i - 1] + (e);
}
```
## p2 球和花瓶悖論
### 考點  
理論上是priority queue，再用map記數，但因為我沒壓好時間所以vector狂sort或max_element都可以AC(還有電神用匿名函數)  
但請記得priority queue較快(4ms)  
### 題解
將每個球用pair塞進花瓶(priority queue)，花瓶內排序法:  
```cpp
struct Item {
    int num;
    string str;
};
struct cmp {
    bool operator()(const Item &a, const Item &b) {
        if (a.num == b.num) {
            return a.str > b.str;
        }
        return a.num < b.num;
    }
};
int main(){
    priority_queue<Item, vector<Item>, cmp> pq;
}
```
在放入第10k次球後，對用.top取值及.pop刪除最大值，用map紀錄被取出球的數量，將map搬到vector後照輸出格式排序(map排序也可，方法https://reurl.cc/A3DAMd)  
## p3 DD錯了嗎?
### 這題是啥?
算是dp裸題(題目就告訴你是dp了)，觀察一下可以發現，既然四位vt的開台時間剛好分別是 `1 2 3 4` ，那第 `n` 項的答案就會是前四項的合，拿第 `n = 5` (可以看5小時)做例子，可以發現會是前四項(看了1 2 3 4小時)的和是因為看了1小時只要再看4個小時就可以，看了2小時只需要再看3個小時就好以此類推

### dp式:
```cpp
dp[n] = dp[n-1] + dp[n-2] + dp[n-3] + dp[n-4]
```

### 20%解
暴力下去就可以直接偷到分了(我數字出很小，你甚至可以本地打表手算完喇分)
### 75%解
這邊就需要用到線性dp了，有興趣的可以去看一下這篇講義:
https://hackmd.io/@nowob/SJ6S1TNMxg
這邊不過多贅述基本上就套著上面dp式然後記得判 `n <= 4` 的情況還有記得每次詢問時先用任何方法看說之前有沒有可能求到更後面的數字了，有的話直接在陣列裡把答案叫出來就好不用再浪費時間運算，假如沒有就從上次求到的最高的數字往後算，這裡我用的方式是多一個變數用來維護最大值。  
(後更:我這裡出的測資也出爛了，每次都從1到n也可以過，但希望大家可以學一下線性的最佳解(應該是最佳))  

(然後記得用 `long long` ，有白癡剛剛解沒加卡了十分鐘)  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MOD = 1e9 + 7;
int main (){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin >> t;	
	vector<ll>dp(1e4 + 1, 0);
	dp[1] = 1;
	dp[0] = 0;
	int mx = 1;
	while(t--){
	int n;
	cin >> n;
	if (n <= mx) cout << dp[n] << '\n';
	else{
		for(int i = mx; i <= n; i++){
			if ( i == 1 ) dp[i] = 1;
			else if ( i == 2 ) dp[i] = dp[i-1] + 1;//這裡要加一因為可以只看兩小時，然後這顯然事前項推不到得所以直接特判，下面的以此類推 
			else if ( i == 3 ) dp[i] = dp[i-1] + dp[i-2] + 1;
			else if ( i == 4 ) dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + 1;
			else dp[i] = (dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]) % MOD;
		}
		cout << dp[n] << '\n';
		}
		mx = max(mx,n);
	}
}
```
### 95%解  
難度開始上去了，白話說就是矩陣快速冪(記得MOD要加const，不然會出事)  
### AC解  
我的解是 `kitamasa` 但因為出的沒有很好所以95%壓常基本上就可以過，然後因為95%以上有點超鋼所以這裡不會詳細解釋，之後上課上到 `dp` 會好好跟各位解釋
:::spoiler 小聲說  
這題一開始是打算防破台才出成這鬼樣子，結果沒幾天就被宇博殺掉了嗚嗚嗚  
:::  

## p4 迷宮
## 考點  
bfs 廣度優先搜尋   

### 50%（K = 0）  
因為沒體力破牆所以就是普通的BFS  
:::success 
### 什麼是BFS  
從起點開始，每次都往 **現在所在的格子** 的上下左右擴散一格，直到抵達終點。   
那我們可以開一個queue， **現在所在的格子** 就是queue的front，擴散的格子就把它push到queue的末端。  
#### 還要再開一張地圖(叫他 visited)，紀錄(i, j)有沒有被bfs走過，有走過的話就不要再走過一次不然會無限迴圈。  
:::
示意圖：https://www.redblobgames.com/pathfinding/early-exit/   
### 100%（K != 0）
~~(((題目出爛100% k 還是等於零~~  
按照前面的作法是行不通的，因為 visited 記錄過的格子如果可以以比 *之前記錄時的體力值* 更高的體力值抵達這裡 那他就有可能走出和 *記錄時* 不一樣的可能性。  
所以 visited 要記錄 **抵達這一格時的體力值**  
如果新來的體力值
- 比較高 就覆蓋之
- 比較低(或等於) 就不要再走了 因為不可能走出和 *記錄時* 不一樣的可能性。

```cpp
#include<bits/stdc++.h>
using namespace std;


typedef pair<int, int> Pos;
#define x first
#define y second
vector<Pos> dways = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
Pos operator+(Pos &a, Pos &b)
{
    return {a.x+b.x, a.y+b.y};
}

typedef pair<int, pair<int, Pos>> bfs_unit;
#define p second.second
#define k second.first



inline int &in(vector<vector<int>> &g, Pos a)
{
    return g[a.x][a.y];
}
int main()
{
    int n, m, K;
    cin >> n >> m >> K;
    vector<vector<int>> graph(n+2, vector<int>(m+2, INT_MAX));
    vector<vector<int>> visited(n+2, vector<int>(m+2, -1));
    Pos start, end;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cin >> graph[i][j];
            if(graph[i][j] == -1)
            {
                start = {i, j};
                visited[i][j] = K;
            }
            if(graph[i][j] == -2)
            {
                end = {i, j};
                graph[i][j] = 0;
            }
        }
    }
    queue<bfs_unit> bfs;
    bfs.push({0, {K, start}});
    while(!bfs.empty())
    {
        auto now = bfs.front();
        if(now.p == end)break;
        bfs.pop();
        for(auto &d : dways)
        {
            if(in(graph, now.p+d) > now.k)continue;
            if(in(visited, now.p+d) >= now.k)continue;
            in(visited, now.p+d) = now.k;
            bfs.push({now.first+1, {now.k-in(graph, now.p+d), now.p+d}});
        }
    }
    if(bfs.empty()) cout << "-1";
    else cout << bfs.front().first;
}
```